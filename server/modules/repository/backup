package repository

import (
	"GitHelper/server/models"
	"context"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/google/go-github/github"
	"github.com/labstack/echo"
)

func Init(o *echo.Group) {
	o.GET("/repos", GetAllRepos)
}

func GetAllRepos(c echo.Context) error {
	fmt.Println("Get repos")
	ctx := context.Background()
	client := models.NewGithubClient(ctx)
	// list all repositories for the authenticated user
	repos, _, err := client.Repositories.List(ctx, "", nil)
	if err != nil {
		fmt.Println("error:", err)
	}

	fmt.Println("repo", len(repos), *repos[1].Owner.Login, *repos[1].Name)
	var baseRef *github.Reference
	if baseRef, _, err = client.Git.GetRef(ctx, "rchanger", "imdb_example", "refs/heads/master"); err != nil {
		// return nil, err
		fmt.Println("err", err)
		log.Fatal(err)
	}
	fmt.Println("bas", baseRef)

	commitBranch := "abcd_" + time.Now().Format("020120071504")
	newRef := &github.Reference{Ref: github.String("refs/heads/" + commitBranch), Object: &github.GitObject{SHA: baseRef.Object.SHA}}

	ref, _, err := client.Git.CreateRef(ctx, "rchanger", "imdb_example", newRef)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("ref:err", ref, err)

	//Create Tree
	entries := []*github.TreeEntry{}
	sourceFiles := "/home/srokade/workspace/goworkspace/src/imdb_example/README.md"
	// Load each file into the tree.
	for _, fileArg := range strings.Split(sourceFiles, ",") {
		file, content, err := getFileContent(fileArg)
		fmt.Println("name:", file)
		if err != nil {
			log.Fatal("read", err)
		}
		entries = append(entries, &github.TreeEntry{Path: github.String("README.md"), Type: github.String("blob"), Content: github.String(string(content)), Mode: github.String("100644")})
	}

	tree, _, err := client.Git.CreateTree(ctx, "rchanger", "imdb_example", *ref.Object.SHA, entries)
	if err != nil {
		log.Fatal(">>>>>tree", err)
	}
	fmt.Println("tree", tree)

	//push commit
	parent, _, err := client.Repositories.GetCommit(ctx, "rchanger", "imdb_example", *ref.Object.SHA)
	if err != nil {
		log.Fatal("parent", err)
	}
	fmt.Println("parent", parent)

	parent.Commit.SHA = parent.SHA
	autherName := "Suvarna"
	autherEmail := "suvarnarokade11@gmail.com"
	commitMessage := "Test commit on readme"
	date := time.Now()
	author := &github.CommitAuthor{Date: &date, Name: &autherName, Email: &autherEmail}
	commit := &github.Commit{Author: author, Message: &commitMessage, Tree: tree, Parents: []*github.Commit{parent.Commit}}

	newCommit, _, err := client.Git.CreateCommit(ctx, "rchanger", "imdb_example", commit)
	if err != nil {
		log.Fatal("newCommit", err)
	}

	fmt.Println("newCommit")

	// Attach the commit to the master branch.
	ref.Object.SHA = newCommit.SHA

	_, _, err = client.Git.UpdateRef(ctx, "rchanger", "imdb_example", ref, false)

	if err != nil {
		log.Fatal("update", err)

	}

	//pull request

	prSubject := "Test PR creation"

	baseBranch := "master"

	prDescription := "Test pr creation"

	newPR := &github.NewPullRequest{
		Title:               &prSubject,
		Head:                &commitBranch,
		Base:                &baseBranch,
		Body:                &prDescription,
		MaintainerCanModify: github.Bool(true),
	}

	pr, _, err := client.PullRequests.Create(ctx, "rchanger", "imdb_example", newPR)
	if err != nil {
		log.Fatal("pr>>", err)
	}

	fmt.Printf("PR created: %s\n", pr.GetHTMLURL())

	return c.JSON(http.StatusOK, repos)
}

func getFileContent(fileArg string) (targetName string, b []byte, err error) {
	var localFile string
	files := strings.Split(fileArg, ":")
	switch {
	case len(files) < 1:
		return "", nil, errors.New("empty `-files` parameter")
	case len(files) == 1:
		localFile = files[0]
		targetName = files[0]
	default:
		localFile = files[0]
		targetName = files[1]
	}

	b, err = ioutil.ReadFile(localFile)
	return targetName, b, err
}
